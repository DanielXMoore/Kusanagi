# Test grammar with function application, arrays, and indentation

File
  Init Line* -> $2

Init
  "" ->
    global.currentIndent = 0
    global.indentLevels = []

PushIndent
  "" ->
    global.indentLevels.push(global.currentIndent)

PopIndent
  "" ->
    global.indentLevels.pop()

Line
  Indent PushIndent LineBody PopIndent EOS -> $3

Indent
  ( "  " / "\t" )* ->
    return global.currentIndent = $1.length

Id
  [a-z]+

Application
  Id _+ Expression _* ListPart* ->
    return {
      type: "application",
      fn: $1,
      arguments: [$3, ...$5],
    }
  Id "(" _* ")" ->
    return {type: "application", fn: $1, arguments: []}
  Id "(" _* Expression ")" ->
    return {
      type: "application",
      fn: $1,
      arguments: [$4],
    }
  Id "(" _* Expression _* ListPart* ")" ->
    return {
      type: "application",
      fn: $1,
      arguments: [$4, ...$6],
    }
  # TODO: Indented function application
  # Id EOS IndentedPart+ ->
  #   return {
  #     type: "application",
  #     fn: $1,
  #     arguments: $3,
  #   }

Expression
  Application
  Bracket
  Id

LineBody
  Expression

Indented
  #TODO: one further than current indent
  "" ->
    throw new Error("TODO")

Bracket
  "[" _* "]" ->
    return []
  "[" _* Expression _* "]" ->
    return [ $3 ]
  "[" _* Expression _* ListPart* "]" ->
    return [ $3 ].concat($5)
  # Single indent at first postion
  "[" EOS IndentedPart* _* "]" -> $3

ListPart
  "," _* Expression _* -> $3

IndentedPart
  Indent Expression EOS ->
    return $2

# Non-newline whitespace
_
  /[ \t]+/

EOS
  (_? EOL)
  EOF

EOL
  "\r\n"
  "\n"
  "\r"

EOF
  !/[\s\S]/
