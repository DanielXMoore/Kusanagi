## Currently adapting from Grammar.txt

Prog
  Init Imp*:imps Declaration*:decs $__:post ->
    return {
      type: "program",
      decs: imps.concat(decs),
      post: post
    }

StatementDelimiter
  ";"
  &EOS

Imp
  $__:pre "import" PatNullary:pat __ "="? __ Text:source StatementDelimiter -> {type: "import", source, pat, pre}

Declaration
  $__:pre Dec:dec StatementDelimiter -> [pre, dec]

ObjSort
  "object"
  "actor"
  "module"

SharedPatOpt
  ("shared" _)? ("query" _)? (PatPlain _)?

TypObj
  __:pre "{" $__:afterOpen DelimitedTypField*:decs $__:beforeClose "}" -> { type: "block", decs, pre, afterOpen, beforeClose }
  __ "{" __ "}"
  # NOTE: Using "block" for code generation to handle semi-colon delimited object fields
  $RestOfLine:pre $EOS?:afterOpen NestedTypFields:nested ->
    const [indent, decs] = nested

    return {
      type: "block",
      decs,
      pre: pre.replace(/^\n$/, " "),
      afterOpen: "\n" + afterOpen,
      beforeClose: "\n" + "".padStart(indent * 2)
    }

DelimitedTypField
  $__:pre TypField:field $__:post BlockFieldDelimiter -> [pre, field, post]

TypField
  $"var"?:prefix $(__ Id):id TypeSuffix:suffix -> { type: "typefield", prefix, id, suffix }
  # TODO: ast nodes
  Id Typing TypNullary TypeSuffix

BlockFieldDelimiter
  # TypFields end with a semi-colon or an optional final semi-colon then the closing brace
  ";"
  ";"? &( __ "}" )

NestedTypFields
  PushIndent NestedTypField*:fields PopIndent:indent ->
    if (!fields.length) return $skip
    return [indent, fields]

NestedTypField
  $Nested:pre TypField:field &EOS -> [pre, field]

TypVariant
  $(__ "{" __ "#" __ "}")
  # NOTE: Using block node for code generation since it wraps with braces and delimits with semi-colons
  $__:pre "{" TypVariantField*:tags $__:beforeClose "}" -> { type: "block", decs: tags, pre, beforeClose }
  # NOTE: Using block node for code generation since it wraps with braces and delimits with semi-colons
  $RestOfLine:pre $EOS?:afterOpen NestedTypTags:nested ->
    const [indent, tags] = nested

    return {
      type: "block",
      decs: tags,
      pre: pre.replace(/^\n$/, " "),
      afterOpen: "\n" + afterOpen,
      beforeClose: "\n",
    }

TypVariantField
  __ TypTag:typTag BlockFieldDelimiter -> typTag

NestedTypTags
  PushIndent NestedTypTag*:tags PopIndent:indent ->
    if (!tags.length) return $skip
    return [indent, tags]

NestedTypTag
  $Nested:pre TypTag:tag &EOS -> [pre, tag]

TypNullary
  __ "(" TypItemField* __ ")"
  __ "[" __ "var"? __ Typ __ "]"
  TypVariant
  TypObj
  __ Id ("." Id)* TypArgs?

TypItemField
  __ TypItem __ TypItemDelimiter

TypItemDelimiter
  ","
  ","? __ &")"

TypUn
  TypNullary
  "?" TypUn

TypPre
  # NOTE: converted recursive "async" to optional
  "async"? __ ObjSort:type __ TypObj:body ->
    var exp = { type, body }
    if ($1) return { type: "async", exp }
    return exp

  ("async" __)? TypUn:exp ->
    if ($1) {
      return {type: "async", exp}
    } else {
      return exp
    }

FuncSortOpt
  "shared" __ "query"?
  "query"
  __

TypNobin
  __ FuncSortOpt (__ Typing)? __ TypUn __ "->" __ TypNobin
  TypPre

Typ
  TypNobin:base TypRest*:rest ->
    if(rest.length) {
      return [base, ...rest]
    }
    return base
  # NOTE: Eliminated left recursion

TypRest
  __ "and" __ Typ
  __ "or"  __ Typ

TypItem
  Id TypeSuffix
  Typ

TypArgs
  "<" TypArgField* ">"

TypArgField
  __ Typ ( ("," __) / (","? __ &">") )

TypTag
  $("#" Id __):id TypeSuffix?:suffix -> { type: "typetag", id, suffix }

TypBind
  Id __ "<:" __ Typ
  Id

Bool
  "true"
  "false"

Ascii
  [\x00-\x7f]

AsciiNoNL
  [\x00-\x09\x0b-\x7f]

Utf8Cont
  [\x80-\xbf]

Utf8Enc
  [\xc2-\xdf] Utf8Cont
  [\xe0] [\xa0-\xbf] Utf8Cont
  [\xed] [\x80-\x9f] Utf8Cont
  [\xe1-\xec\xee-\xef] Utf8Cont Utf8Cont
  [\xf0] [\x90-\xbf] Utf8Cont Utf8Cont
  [\xf4] [\x80-\x8f] Utf8Cont Utf8Cont
  [\xf1-\xf3] Utf8Cont Utf8Cont Utf8Cont

Utf8
  Ascii
  Utf8Enc

Utf8NoNL
  AsciiNoNL
  Utf8Enc

Escape
  [nrt\\'"]

# https://github.com/dfinity/motoko/blob/master/doc/modules/language-guide/pages/language-manual.adoc#characters
Character
  [^"\\\x00-\x1f\x7f-\xff]
  Utf8Enc
  "\\" Escape
  "\\" HexDigit HexDigit
  "\\u{" HexNumber "}"

# https://github.com/dfinity/motoko/blob/master/doc/modules/language-guide/pages/language-manual.adoc#text
Text
  $("\"" $(Character*) "\"")

Char
  $("'" Character "'")

ReservedWord
  /(actor|and|assert|await|break|case|catch|class|continue|debug|debug_show|do|else|flexible|false|for|func|if|ignore|in|import|not|null|object|or|label|let|loop|private|public|query|return|shared|stable|system|switch|true|try|type|var|while)\s/

# https://github.com/dfinity/motoko/blob/master/doc/modules/language-guide/pages/language-manual.adoc#identifiers
Id
  !ReservedWord $(/[a-zA-Z][a-zA-Z0-9_]*/):id -> id

Digit
  [0-9]

HexDigit
  [0-9a-fA-F]

Number
  # NOTE: Keeping numbers as a text string exactly as written
  $(Digit ( "_"? Digit )*)

HexNumber
  # NOTE: Keeping numbers as a text string exactly as written
  $(HexDigit ( "_"? HexDigit )*)

# https://github.com/dfinity/motoko/blob/master/doc/modules/language-guide/pages/language-manual.adoc#integers
Nat
  "0x" HexNumber
  Number

# https://github.com/dfinity/motoko/blob/master/doc/modules/language-guide/pages/language-manual.adoc#floats
Float
  "0x" HexNumber "." HexNumber?
  "0x" HexNumber ( "." HexNumber? )? [pP] [-+]? Number
  Number "." Number?
  Number ( "." Number? )? [eE] [-+]? Number

# https://github.com/dfinity/motoko/blob/master/doc/modules/language-guide/pages/language-manual.adoc#literals
Lit
  "null"
  Bool
  $(Nat)
  $(Float)
  Char
  Text

# https://github.com/dfinity/motoko/blob/master/doc/modules/language-guide/pages/language-manual.adoc#unary-operators
Unop
  "+"
  "-"
  "^"

# https://github.com/dfinity/motoko/blob/master/doc/modules/language-guide/pages/language-manual.adoc#numeric-binary-operators
# https://github.com/dfinity/motoko/blob/master/doc/modules/language-guide/pages/language-manual.adoc#bitwise-and-wrapping-binary-operators
Binop
  "**"
  "+%"
  "-%"
  "*%"
  "**%"
  "<<>"
  "<>>"
  "<<"
  ">>" # NOTE: removed leading whitespace
  # https://github.com/dfinity/motoko/blob/master/doc/modules/language-guide/pages/language-manual.adoc#text-operators
  "#"
  "+"
  "-"
  "*"
  "/"
  "%"
  "&"
  "|"
  "^"

# https://github.com/dfinity/motoko/blob/master/doc/modules/language-guide/pages/language-manual.adoc#relational-operators
# NOTE: removed surrounding whitespace from angle brackets since PEG doesn't have a separate tokenization phase and has more
# context for the operator. May need to add it back later to be strictly match the spec. Can likely use a RegExp lookahead
# assertion for the whitespace matching in ExpBinRest if necessary.
Relop
  "=="
  "!="
  "<="
  ">="
  "<" # NOTE: removed surrounding whitespace
  ">" # NOTE: removed surrounding whitespace

# https://github.com/dfinity/motoko/blob/master/doc/modules/language-guide/pages/language-manual.adoc#assignment-operators
Unassign
  "+="
  "-="
  "^="

# https://github.com/dfinity/motoko/blob/master/doc/modules/language-guide/pages/language-manual.adoc#assignment-operators
Binassign
  "+="
  "-="
  "*="
  "/="
  "%="
  "**-"
  "+%="
  "-%="
  "*%="
  "**%="
  "&="
  "|="
  "^="
  "<<="
  ">>="
  "<<>="
  "<>>="
  "@="
  "#=" # NOTE: Added
  ":=" # NOTE: Moved here from ExpNondec

ExpObj
  # Object Pattern https://github.com/dfinity/motoko/blob/master/doc/modules/language-guide/pages/language-manual.adoc#object-pattern
  # This different from PatNullary because exp fields can optionally start with "var"
  $( __ "{" __ ExpObjField* "}")
  # NOTE: Added indentation based object syntax
  $__:pre "{" NestedObjectFields:fields $__:beforeClose "}" ->
    return {
      type: "block",
      decs: fields,
      pre,
      beforeClose
    }

ExpObjField
  # NOTE: Extracted field rule for easier iteration
  ExpField:field __ ( ";" / (__ &"}") ) __ -> field

NestedObjectFields
  PushIndent NestedObjectField*:fields PopIndent -> fields

NestedObjectField
  $Nested:pre ExpField:field &EOS -> [pre, field]

ExpPlain
  $_? Lit
  # NOTE: Extracted expression part for easier iteration
  $_?:pre "(" __ ExpPlainPart*:exps ")" -> { type: "parens", exps, pre }
  # NOTE: Added Parentheses-less tuple
  $(_ TrailingComments):pre Exp:first CommaExp*:exps ->
    return { type: "parens", exps: [first, ...exps], pre: pre.replace(/ $/, "") }

ExpPlainPart
  Exp:exp __ ( "," / (__ &")") ) __ -> exp

CommaExp
  "," __ Exp:exp -> exp

ExpNullary
  ExpObj
  ExpPlain
  Id

ExpPost
  ExpNullary:exp ExpPostRest*:rest ->
    if (rest.length) {
      return {
        // TODO better naming
        type: "exppost",
        base: exp,
        rest: rest,
      }
    } else {
      return exp
    }
  # Array
  # https://github.com/dfinity/motoko/blob/master/doc/modules/language-guide/pages/language-manual.adoc#arrays
  # NOTE: Added indentation based array syntax
  "[" $((_? "var")?):prefix EOS NestedArrayParts:exps $__:beforeClose "]" -> { type: "array", prefix, exps, beforeClose }
  "[" __ $(( "var" __ )?):prefix ArrayPart*:exps "]" -> { type: "array", prefix, exps }
  # NOTE: Eliminated left recursion

ArrayPart
  # TODO: Internal whitespace / comments
  ExpNonvar:exp ( "," / (__ &"]") ) __ -> exp

NestedArrayParts
  PushIndent NestedArrayPart*:exps PopIndent -> exps

NestedArrayPart
  $Nested:pre ExpNonvar:exp &EOS -> [pre, exp]

ExpPostRest
  # Array Indexing
  # https://github.com/dfinity/motoko/blob/master/doc/modules/language-guide/pages/language-manual.adoc#array-indexing
  "[" Exp:exp "]" ->
    return {
      type: "index",
      exp,
    }
  # Tuple Projection
  # https://github.com/dfinity/motoko/blob/master/doc/modules/language-guide/pages/language-manual.adoc#tuples
  "." Nat:nat ->
    return {
      type: "projection",
      id: nat
    }
  # Object Projection (member access)
  # https://github.com/dfinity/motoko/blob/master/doc/modules/language-guide/pages/language-manual.adoc#object-projection-member-access
  "." Id:id ->
    return {
      type: "projection",
      id,
    }
  # Function application
  $((TypArgs __ )?):typArgs ExpNullary:fnArgs ->
    return {
      type: "application",
      typArgs,
      fnArgs
    }
  "!" # Null break

ExpUn
  ExpPost
  # Variant Pattern
  # NOTE: Combined and added `?` to prevent shadowing
  # https://github.com/dfinity/motoko/blob/master/doc/modules/language-guide/pages/language-manual.adoc#variant-pattern
  "#" Id __ ExpNullary?
  "?" ExpUn
  Unop ![\s] ExpUn
  Unassign ExpUn
  "actor" ExpPlain
  "not" ExpUn
  "debug_show" ExpUn
  "to_candid" "(" ( Exp ( "," Exp )* )? ")"
  "from_candid" ExpUn

ExpBin
  # NOTE: Eliminated left recursion
  ExpUn:exp ExpBinRest*:rest ->
    if (rest.length) {
      return {
        type: "expbin",
        exps: [exp].concat(...rest),
      }
    } else {
      return exp
    }

ExpBinRest
  __ Binop __ ExpBin
  __ Relop __ ExpBin
  __ "and" __ ExpBin
  __ "or"  __ ExpBin
  __ ":"   __ TypNobin

ExpNondec
  "return" __ Exp?:exp ->
    return {type: "return", exp}
  "async"    ExpNest:exp -> { type: "async",  exp }
  "await"    ExpNest:exp -> { type: "await",  exp }
  "assert"   ExpNest:exp -> { type: "assert", exp }
  "label"    ($__ Id):id TypeSuffix?:typeSuffix ExpNest:exp -> { type: "label", id, typeSuffix, exp }
  "break"    ($__ Id):id ExpNullary?:exp -> { type: "break", id, exp }
  "continue" ($__ Id):id -> { type: "continue", id }
  "debug"    ExpNest:exp -> { type: "debug", exp }
  "if"       ExpNullary:condition ExpNest:exp ElseBlock?:elseBlock -> { type: "if", condition, exp, elseBlock }
  "try"      ExpNest:exp $__:pre Catch:c -> { type: "try", exp, catch: c, pre }
  "throw"    ExpNest:exp -> { type: "throw", exp }
  "switch"   ExpNullary:condition $__:pre "{" $__:afterOpen Case*:cases $__:beforeClose "}" ->
    return {
      type: "switch",
      condition,
      cases: {
        type: "block",
        decs: cases,
        pre,
        afterOpen,
        beforeClose,
      }
    }
  # NOTE: Added brace-less switch
  "switch"   ExpNullary:condition $RestOfLine:pre $EOS?:afterOpen NestedCases:nested ->
    const [indent, cases] = nested

    return {
      type: "switch",
      condition,
      cases: {
        type: "block",
        decs: cases,
        pre: pre.replace(/^\n$/, " "),
        afterOpen: "\n" + afterOpen,
        beforeClose: "\n" + "".padStart(indent * 2),
      }
    }
  "while"    ExpNullary:condition ExpNest:exp -> { type: "while", condition, exp }
  "loop"     ExpNest:exp WhileBlock?:whileBlock -> { type: "loop", exp, whileBlock }
  "for"      __ "(" __ Pat:pat __ "in" __ Exp:source __ ")" ExpNest:exp -> { type: "for", pat, source, exp }
  # NOTE: Added paren-less `for`
  "for"      _ Pat:pat __ "in" __ Exp:source ExpNest:exp -> { type: "for", pat, source, exp }
  "ignore"   ExpNest:exp -> { type: "ignore", exp }
  "do"        Block:block -> { type: "do", block }
  "do" __ "?" Block ->       { type: "do", block, option: true }
  # NOTE: Moved ":=" into Binassign
  ExpBin:base __ Binassign:op __ Exp:exp -> { type: "binassign", base, op, exp}
  ExpBin

ElseBlock
  $__ "else" ExpNest

WhileBlock
  $__ "while" ExpNest

ExpNonvar
  ExpNondec
  DecNonvar

Exp
  ExpNonvar
  DecVar

ExpNest
  Block
  $__ Exp

Block
  $__:pre "{" __ BlockDeclaration*:decs "}" -> { type: "block", decs, pre }
  $RestOfLine:pre $EOS?:afterOpen NestedBlockDeclarations:nested $TrailingComments:beforeClose ->
    const [indent, decs] = nested

    // Skip if there were no indented declarations found
    if (!decs.length) return $skip

    return {
      type: "block",
      decs,
      pre: pre.replace(/^\n$/, " "),
      afterOpen: "\n" + afterOpen,
      beforeClose: beforeClose + "\n" + "".padStart(indent * 2),
    }

NestedBlockDeclarations
  # TODO: PopIndent should return number of current indent level
  PushIndent NestedBlockDeclaration*:decs PopIndent:indent -> [indent, decs]

NestedBlockDeclaration
  $Nested:pre Dec:dec &EOS -> [pre, dec]

# NOTE: Extracted block declaration with optional trailing semi-colon when object closes to make field iteration easier in Block
BlockDeclaration
  Dec:dec __ ( ";" / (__ &"}") ) __ -> dec

Case
  $__:pre "case" PatNullary:pat ExpNest:exp BlockFieldDelimiter ->
    return {
      type: "case",
      pat,
      exp,
      pre,
    }

NestedCases
  PushIndent NestedCase*:cases PopIndent:indent ->
    if (!cases.length) return $skip
    return [indent, cases]

NestedCase
  $Nested:pre "case" PatNullary:pat ExpNest:exp &EOS ->
    return {
      type: "case",
      pat,
      exp,
      pre,
    }

Catch
  "catch" PatNullary:pat ExpNest:exp ->
    return {
      type: "catch",
      pat,
      exp,
    }

ExpField
  "var"? __ Id TypeSuffix? (__ "=" __ Exp)?

DecField
  $(( Vis __ )? ( Stab __ )?):prefix Dec:dec ->
    return { type: "dec", prefix, dec }

Vis
  "private"
  "public"
  "system"

Stab
  "flexible"
  "stable"

PatPlain
  __ "(" __ PatPlainPart*:parts ")" ->
    return {
      type: "parens",
      exps: parts,
    }
  # NOTE: Added Parentheses-less tuple
  _ PatBin:first CommaPat*:pats ->
    if (pats.length)
      return { type: "parens", exps: [first, ...pats] }
    return first
  "_"
  Id
  Lit

# NOTE: Extracted PatPlainPart with optional trailing comma before close parenthesis
PatPlainPart
  # TODO: Manage internal comment and whitespace tokens
  PatBin:pat __ ( "," / (__ &")") ) __ -> pat

CommaPat
  # TODO: Manage internal comment and whitespace tokens
  "," __ PatBin:pat -> pat

PatNullary
  PatPlain
  # Object Pattern https://github.com/dfinity/motoko/blob/master/doc/modules/language-guide/pages/language-manual.adoc#object-pattern
  # TODO: Add indentation based object syntax
  $("{" ( PatField (";" PatField )* )? "}") # Return string as written for now

PatUn
  PatNullary
  "#" Id PatNullary? # NOTE: Merged in "#" Id with optional nullary to prevent shadowing
  "?" __ PatUn
  Unop Lit

PatBin
  PatUn:first PatBinRest*:rest ->
    if (!rest.length) {
      return first
    } else {
      return [first].concat(...rest)
    }
  # NOTE: Eliminated left recursion

PatBinRest
  $__ "or" $__ PatBin
  $__ ":"  $__ Typ

Pat
  PatBin

PatField
  Id TypeSuffix? __ "=" __  Pat
  Id TypeSuffix?

DecVar
  # TODO: Manage internal comment and whitespace tokens
  "var" __ Id:id __ $(TypeSuffix?):typeSuffix __ "=" __ Exp:exp ->
    return { type: "var", id, exp, typeSuffix}

DecNonvar
  "let"  __ Pat __ "=" __ Exp
  "type" __ Id  (__ Typing)? __ "=" Typ

  ObjSort:type $(__ Id)?:id (__ "=")? ObjBody:body ->
    return { id, type, body }

  $(SharedPatOpt):shared "func" $(__ Id?):id ($__ Typing)?:typing ($__ PatPlain):pat $(TypeSuffix?):typeSuffix FuncBody:body ->
    return { type: "func", shared, id, typing, pat, typeSuffix, body}
  $(SharedPatOpt):shared $(ObjSort?):sort $__ "class" ($__ Id)?:id ($__ Typing)?:typing ($__ PatPlain):pat $(TypeSuffix?):typeSuffix ClassBody:body ->
    return { type: "class", sort, shared, id, typing, pat, typeSuffix, body}

TypeSuffix
  $__ ":" $__ Typ:typ

Typing
  "<" TypingField* ">"

TypingField
  TypBind __ ( ("," __) / &">" )

Dec
  DecVar
  DecNonvar
  ExpNondec

FuncBody
  Block
  $__:pre "=" $__:preExp Exp:exp ->
    return [pre, {
      type: "=",
      exp: [preExp, exp]
    }]

ObjBody
  # TODO: internal whitespace and comment handling
  $__:pre "{" __ ObjBodyField*:decs "}" __ ->
    return {
      type: "block",
      decs: decs,
      pre,
    }
  $RestOfLine:pre $EOS?:afterOpen NestedObjBodyFields:nestedFields ->
    const [indent, decs] = nestedFields

    return {
      type: "block",
      decs: decs,
      pre: pre.replace(/^\n$/, " "),
      afterOpen: "\n" + afterOpen,
      beforeClose: "\n" + "".padStart(indent * 2),
    }

# NOTE: Extracted dec-field with optional trailing semi-colon when object closes to make field iteration easier in ObjBody
ObjBodyField
  # TODO: whitespace and comment handling
  DecField:field __ ( ";" / (__ &"}") ) __ -> field

NestedObjBodyFields
  PushIndent NestedObjBodyField*:fields PopIndent:indent -> [indent, fields]

NestedObjBodyField
  $Nested:pre DecField:field &EOS -> [pre, field]

ClassBody
  # TODO: Whitespace and comment handling
  __ "=" __ Id?:id __ ObjBody:exp ->
    return {
      type: "=",
      id,
      exp,
    }
  ObjBody

# https://github.com/dfinity/motoko/blob/master/doc/modules/language-guide/pages/language-manual.adoc#comments
Comment
  $MultilineComment
  $SingleLineComment

# https://github.com/dfinity/motoko/blob/master/doc/modules/language-guide/pages/language-manual.adoc#comments
MultilineComment
  # Note: Allows for nested Comments
  "/*" ( (!("/*" / "*/") . ) / MultilineComment )* "*/"

# https://github.com/dfinity/motoko/blob/master/doc/modules/language-guide/pages/language-manual.adoc#comments
SingleLineComment
  /\/\/[^\r\n]*/

# Any or no whitespace including newlines and comments
__
  ([\s]+ / Comment)*

# Non-newline whitespace
_
  /[ \t]+/

# End of statemnt
EOS
  RestOfLine+ _ EOF
  RestOfLine+
  EOF

RestOfLine
  TrailingComments EOL

# Trailing comments within a single logical line (newlines within a multi-line comment don't count
TrailingComments
  (_? Comment?)*

# End of line
EOL
  "\r\n"
  "\n"
  "\r"

# End of file
EOF
  !/[\s\S]/

# Indentation management

Indent
  ( "  " / "\t" )* ->
    return $1.length

Nested
  EOS? Indent:indent ->
    const currentIndent = global.indentLevels[global.indentLevels.length-1]
    if (global.verbose) {
      console.log("global indent", global.currentIndent)
      console.log("Indented", indent, currentIndent)
    }
    if (indent !== currentIndent) {
      if (global.verbose) {
        console.log("skipped nested")
      }
      return $skip
    }
    return indent

Init
  "" ->
    global.currentIndent = 0
    global.indentLevels = [0]
    global.verbose = false

PushIndent
  "" ->
    global.currentIndent++
    if (global.verbose) {
      console.log("pushing indent", global.currentIndent)
    }
    global.indentLevels.push(global.currentIndent)

    return global.currentIndent

PopIndent
  "" ->
    if (global.verbose) {
      console.log("popping indent", global.indentLevels[global.indentLevels.length-1], "->", global.indentLevels[global.indentLevels.length-2])
    }
    global.indentLevels.pop()
    global.currentIndent = global.indentLevels[global.indentLevels.length-1]

    return global.currentIndent
